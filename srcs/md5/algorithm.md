# Algorithm steps
There are 5 steps of the algorithm

The example: 
$ echo -n "5" | md5     
e4da3b7fbbce2345d7772b0674a318d5

## Preparation
"5" is 53 in decimal and 00110101 in binary

## First step: Prepare 512-bit blocks
The padding works as follows: first a single bit, 1, is appended to the end of the message. This is followed by as many zeros as are required to bring the length of the message up to 64 bits fewer than a multiple of 512.

1. We take our string in binary and write it as a 64-bit sequence (as programming calculators do)
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00110101
length = 64 bit

2. We add 1
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00110101 \
1
length = 65 bit

3. We add zeros till "length mod 512 = 448"
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00110101 \
10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
length = 448 bit (64 bit in a line * 7 lines)

4. We add the length of the message as 32 least significant bit and 32 most significant bit
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00110101 \
10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00110101 00000000 00000000 00000000 00000000
length = 512 bit (64 bit in a line * 8 lines)

## Second step: Prepare buffers for calculations
We will use the following formula:
[abcd k s i]
a = b + ((a + {Fun}(b,c,d) + X[k] + T[i]) <<< s)
And have 4 plays with 16 rounds in each.

1. Prepare the init vector:
a0 = 01 23 45 67; // 0x67452301
b0 = 89 AB CD EF; // 0xEFCDAB89
c0 = FE DC BA 98; // 0x98BADCFE
d0 = 76 54 32 10. // 0x10325476
These 4 variables will save the middle state during the calculations

2. Specify the per-round shift amounts - variable s (shifts)
var int s[64]
s[0..15] := {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22} - 1st play
s[16..31] := {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20} - 2nd play
s[32..47] := {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23} - 3rd play
s[48..63] := {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21} - 4th play
These variables are stated

3. Specify the table of constants according to formula
T[1...64] 
T[n]={int}(2^{32}*|sin n|)

There are ready tables:
X[0..3] := {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee}
X[4..7] := {0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501}
X[8..11] := {0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be}
X[12..15] := {0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821}
X[16..19] := {0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa}
X[20..23] := {0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8}
X[24..27] := {0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed}
X[28..31] := {0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a}
X[32..35] := {0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c}
X[36..39] := {0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70}
X[40..43] := {0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05}
X[44..47] := {0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665}
X[48..51] := {0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039}
X[52..55] := {0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1}
X[56..59] := {0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1}
X[60..63] := {0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391}

## Third step: Perform the calculations

1. Break our ready message (we have only one 512-bit block) into 16 blocks of 32 bit
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00110101 \
10000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00000000 \
00000000 00000000 00000000 00110101 \
00000000 00000000 00000000 00000000

2. Prepare variables
var int A := a0
var int B := b0
var int C := c0
var int D := d0

3. Make calculations
/* [abcd k s i] a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
where X[k] - k = 0..63 - value from the table of consts;
T[i] - i = 0..15 - index of the 32-bit block of data
s - const shift from the ready-table

First play and first round:
{FunF}(X,Y,Z)=(X and Y) or (not X and Z),

	[ABCD  0 7  1]
	A = 0xEFCDAB89 + ((0x67452301 + F(0xEFCDAB89, 0x98BADCFE, 0x10325476) + 0xd76aa478 + 0x00) <<< 7), where
	F(0xEFCDAB89, 0x98BADCFE, 0x10325476) = (0xEFCDAB89 and 0x98BADCFE) or \
	(not 0xEFCDAB89 and 0x10325476) = \
	(11101111110011011010101110001001 and 10011000101110101101110011111110) or \
	(not 11101111110011011010101110001001 and 10000001100100101010001110110) = \
	